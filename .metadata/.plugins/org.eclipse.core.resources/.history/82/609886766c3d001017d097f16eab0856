/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32l552.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define BUTTON_RELEASED 0
#define BUTTON_PRESSED 1

enum ClickedButtons
{
	NONE_PRESSED            = 0b000000,
	USER_BUTTON_PRESSED     = 0b000001,
	JOYSTICK_CENTER_PRESSED = 0b000010,
	JOYSTICK_UP_PRESSED     = 0b000100,
	JOYSTICK_DOWN_PRESSED   = 0b001000,
	JOYSTICK_LEFT_PRESSED   = 0b010000,
	JOYSTICK_RIGHT_PRESSED  = 0b100000
};

// User button is on PC13 (active high):
#define USER_BUTTON GPIOC->IDR.IDR13
// Jostick center is on PA0 (active low):
#define JOYSTICK_CENTER GPIOA->IDR.IDR0
// Jostick up is on PF9 (active low):
#define JOYSTICK_UP GPIOF->IDR.IDR9
// Jostick down is on PF8 (active low):
#define JOYSTICK_DOWN GPIOF->IDR.IDR8
// Jostick left is on PE3 (active low):
#define JOYSTICK_LEFT GPIOE->IDR.IDR3
// Jostick right is on PF7 (active low):
#define JOYSTICK_RIGHT GPIOF->IDR.IDR7

// LED green is on PC7:
#define LED1_GREEN GPIOC->ODR.ODR7
// LED blue is on PB7:
#define LED2_BLUE GPIOB->ODR.ODR7
// LED red is on PA9:
#define LED3_RED GPIOA->ODR.ODR9

int delay(int count)
{
	for (volatile int i = 0; i < count * 1000; i++);
	return 1;
}

uint8_t read_buttons_with_delay() {
    static uint8_t button_state = BUTTON_RELEASED;
    static enum ClickedButtons buttons_state = NONE_PRESSED;

    // Read the raw button state
//    uint8_t raw_state = USER_BUTTON ? BUTTON_PRESSED : BUTTON_RELEASED;
    uint8_t raw_state = JOYSTICK_RIGHT ? BUTTON_RELEASED : BUTTON_PRESSED;

    // If state changed
    if (raw_state != button_state) {
        // Simple delay-based debounce
        delay(20);  // Wait ~20ms

        // Read again after delay
//        raw_state = USER_BUTTON ? BUTTON_PRESSED : BUTTON_RELEASED;
        raw_state = JOYSTICK_RIGHT ? BUTTON_RELEASED : BUTTON_PRESSED;

        // Update button state
        button_state = raw_state;
    }

    return button_state;
}

int main(void)
{
	RCC->AHB2ENR.GPIOAEN = ENABLED;
	RCC->AHB2ENR.GPIOBEN = ENABLED;
	RCC->AHB2ENR.GPIOCEN = ENABLED;
	RCC->AHB2ENR.GPIOEEN = ENABLED;
	RCC->AHB2ENR.GPIOFEN = ENABLED;

	GPIOA->MODER.MODER9 = OUTPUT_MODE; // LED3_RED
	GPIOB->MODER.MODER7 = OUTPUT_MODE; // LED2_BLUE
	GPIOC->MODER.MODER7 = OUTPUT_MODE; // LED1_GREEN

	GPIOA->MODER.MODER0 = INPUT_MODE; // Joystick center
	GPIOC->MODER.MODER13 = INPUT_MODE; // User button
	GPIOE->MODER.MODER3 = INPUT_MODE; // Joystick left
	GPIOF->MODER.MODER7 = INPUT_MODE; // Joystick right
	GPIOF->MODER.MODER8 = INPUT_MODE; // Joystick down
	GPIOF->MODER.MODER9 = INPUT_MODE; // Joystick up

	LED1_GREEN = ON;

	do {
		if (read_buttons_with_delay() == BUTTON_PRESSED)
		{
			LED3_RED = ON;
		}
		else
		{
			LED3_RED = OFF;
		}
	} while (1);

	for (;;);
}

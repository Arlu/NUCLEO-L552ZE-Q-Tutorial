/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32l552.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define BUTTON_RELEASED 0
#define BUTTON_PRESSED 1

int delay(int count)
{
	for (volatile int i = 0; i < count * 1000; i++);
}

// Button debouncing using multiple samples approach
uint8_t read_button_multiple_samples(void) {
    static uint8_t button_state = BUTTON_RELEASED;
    static uint8_t counter = 0;
    const uint8_t debounce_count = 10;  // Number of consecutive samples

    // Read raw button state - using the bitfield access like in first program
    uint8_t raw_state = (GPIOA->IDR.IDR0 & BUTTON_PRESSED) ? 1 : 0;

    // Reset counter if state changes
    if (raw_state == button_state)
    {
        if (counter > 0)
        {
            counter--;
        }
    }
    else
    {
        // Increment counter for consistent readings
        if (counter < debounce_count)
        {
            counter++;
        }

        // Update state after sufficient consistent readings
        if (counter >= debounce_count)
        {
            button_state = raw_state;
        }
    }

    return button_state;
}

int main(void)
{
	RCC->AHB2ENR.GPIOBEN = ENABLED;
	RCC->AHB2ENR.GPIOCEN = ENABLED;
	GPIOB->MODER.MODER7 = OUTPUT_MODE;
	GPIOC->MODER.MODER13 = INPUT_MODE;
	GPIOB->ODR.ODR7 = ON;

	do {
		if (read_button_multiple_samples() == BUTTON_PRESSED)
		{
			GPIOB->ODR.ODR7 = ON;
		}
		else
		{
			GPIOB->ODR.ODR7 = OFF;
		}
	} while (delay(200));

	for (;;);
}

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32l552.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define BUTTON_RELEASED 0
#define BUTTON_PRESSED 1

int delay(int count)
{
	for (volatile int i = 0; i < count * 1000; i++);
	return 1;
}

// Button debouncing using multiple samples approach
uint8_t read_button_multiple_samples(void) {
    static uint8_t button_state = BUTTON_RELEASED;
    static uint8_t counter = 0;
    const uint8_t debounce_count = 10;  // Number of consecutive samples

    // Read raw button state - using the bitfield access like in first program
    uint8_t raw_state = GPIOC->IDR.IDR13 ? BUTTON_PRESSED : BUTTON_RELEASED;

    // Reset counter if state changes
    if (raw_state == button_state)
    {
        if (counter > 0)
        {
            counter--;
        }
    }
    else
    {
        // Increment counter for consistent readings
        if (counter < debounce_count)
        {
            counter++;
        }

        // Update state after sufficient consistent readings
        if (counter >= debounce_count)
        {
            button_state = raw_state;
        }
    }

    return button_state;
}

int main(void)
{
	RCC->AHB2ENR.GPIOAEN = ENABLED;
	RCC->AHB2ENR.GPIOBEN = ENABLED;
	RCC->AHB2ENR.GPIOCEN = ENABLED;
	RCC->AHB2ENR.GPIOEEN = ENABLED;
	RCC->AHB2ENR.GPIOFEN = ENABLED;

	GPIOA->MODER.MODER9 = OUTPUT_MODE; // LED3_RED
	GPIOB->MODER.MODER7 = OUTPUT_MODE; // LED2_BLUE
	GPIOC->MODER.MODER7 = OUTPUT_MODE; // LED1_GREEN

	GPIOA->MODER.MODER0 = INPUT_MODE; // Joystick center
	GPIOC->MODER.MODER13 = INPUT_MODE; // User button
	GPIOE->MODER.MODER3 = INPUT_MODE; // Joystick left
	GPIOF->MODER.MODER7 = INPUT_MODE; // Joystick right
	GPIOF->MODER.MODER8 = INPUT_MODE; // Joystick down
	GPIOF->MODER.MODER9 = INPUT_MODE; // Joystick up

	LED1_GREEN = OFF;
	LED2_BLUE = OFF;
	LED3_RED = OFF;

	do {
			enum ClickedButtons buttons_state = read_buttons_with_delay();

			LED3_RED = (buttons_state & (USER_BUTTON_PRESSED | JOYSTICK_LEFT_PRESSED | JOYSTICK_UP_PRESSED)) ? ON : OFF;
			LED2_BLUE = (buttons_state & (USER_BUTTON_PRESSED | JOYSTICK_CENTER_PRESSED | JOYSTICK_UP_PRESSED | JOYSTICK_DOWN_PRESSED)) ? ON : OFF;
			LED1_GREEN = (buttons_state & (USER_BUTTON_PRESSED | JOYSTICK_RIGHT_PRESSED | JOYSTICK_DOWN_PRESSED)) ? ON : OFF;
		} while (1);

	for (;;);
}
